package sql

import (
	"database/sql"
	"errors"
	"github.com/staumann/caluclation/model"
	"log"
)

type userRepo struct {
	adapter *Adapter
}

// SaveUser stores the given userData in the database. The id of the user is generated by the database and added to the user
// object after storage
func (a *userRepo) SaveUser(user *model.User) error {
	res, err := a.adapter.db.Exec(a.adapter.getScript("insert/user"), user.FirstName, user.LastName, user.Image, user.Password)

	if err != nil {
		log.Printf("error saving user: %s", err.Error())
		return err
	}

	user.ID, _ = res.LastInsertId()

	return nil
}

// GetUserById returns the user associated with the given id
func (a *userRepo) GetUserByID(id int64) *model.User {
	user := new(model.User)
	err := a.adapter.db.QueryRow(a.adapter.getScript("/get/user"), id).Scan(&user.ID, &user.LastName, &user.FirstName, &user.Image, &user.Password)

	if err != nil {
		log.Printf("error getting unser: %s", err.Error())
		return nil
	}

	return user
}

func (a *userRepo) GetUsers() []*model.User {
	rows, err := a.adapter.db.Query(a.adapter.getScript("/get/users"), 0)
	if err != nil {
		log.Printf("error getting users: %v", err)
		return nil
	}
	users := make([]*model.User, 0)
	for rows.Next() {
		u := new(model.User)

		if e := rows.Scan(&u.LastName, &u.FirstName, &u.Image, &u.Password); e != nil {
			log.Print(e)
		} else {
			users = append(users, u)
		}
	}
	return users
}

func (a *userRepo) UpdateUser(user *model.User) error {
	tx, err := a.adapter.db.Begin()

	if err != nil {
		log.Printf("error beginning transaction: %s", err.Error())
		return err
	}
	if result, e := tx.Exec(a.adapter.getScript("update/user"), user.FirstName, user.LastName, user.Image, user.Password, user.ID); e != nil {
		return e
	} else {
		count, e := result.RowsAffected()
		if e != nil {
			log.Printf("error getting result: %s", e.Error())
			return e
		}
		if count != 1 {
			if er := tx.Rollback(); er != nil {
				log.Printf("error roling back: %s", er.Error())
				return er
			}
			return errors.New("error more than one row affected rolling back")
		}
		if er := tx.Commit(); er != nil {
			log.Printf("error commiting transcation: %s", er.Error())
		}
	}
	return nil
}

func (a *userRepo) DeleteUserByID(id int64) error {
	tx, err := a.adapter.db.Begin()

	if err != nil {
		log.Printf("error beginning transaction: %s", err.Error())
		return nil
	}
	var result sql.Result
	result, err = tx.Exec(a.adapter.getScript("delete/user"), id)
	if err != nil {
		log.Printf("error executing query: %s", err.Error())
		return err
	}
	var count int64
	count, err = result.RowsAffected()
	if err != nil {
		log.Printf("error getting result: %s", err.Error())
		return err
	}
	if count != 1 {
		log.Printf("error more then 1 row affected")
		if err = tx.Rollback(); err != nil {
			log.Printf("error rolling back: %s", err.Error())
		}
		return errors.New("error more then 1 row affected")
	} else {
		if err = tx.Commit(); err != nil {
			log.Printf("error comitting changes: %s", err.Error())
			return err
		}
	}
	return nil
}
