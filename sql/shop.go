package sql

import (
	"database/sql"
	"errors"
	"github.com/staumann/caluclation/model"
	"log"
)

type shopRepo struct {
	adapter *Adapter
}

// SaveShop stores the given shop data in the database. The id of the shop is generated by the database and added to the shop
// object after storage
func (a *shopRepo) SaveShop(shop *model.Shop) error {
	res, err := a.adapter.db.Exec(a.adapter.getScript("insert/shop"), shop.Name, shop.Street, shop.HouseNumber, shop.PostalCode, shop.City, shop.Infos)

	if err != nil {
		log.Printf("error saving user: %s", err.Error())
		return err
	}

	shop.ID, _ = res.LastInsertId()

	return nil
}

// GetShopByID returns the user associated with the given id
func (a *shopRepo) GetShopByID(id int64) *model.Shop {
	shop := new(model.Shop)
	err := a.adapter.db.QueryRow(a.adapter.getScript("/get/shop"), id).Scan(&shop.ID, &shop.Name, &shop.Street, &shop.HouseNumber, &shop.PostalCode, &shop.City, &shop.Infos)

	if err != nil {
		log.Printf("error getting unser: %s", err.Error())
		return nil
	}

	return shop
}

func (a *shopRepo) GetShops(id int64) []*model.Shop {
	rows, err := a.adapter.db.Query(a.adapter.getScript("/get/shops"), id)
	if err != nil {
		log.Printf("error getting users: %v", err)
		return nil
	}
	shops := make([]*model.Shop, 0)
	for rows.Next() {
		s := new(model.Shop)

		if e := rows.Scan(&s.ID, &s.Name, &s.Street, &s.HouseNumber, &s.City, &s.PostalCode, &s.Infos); e != nil {
			log.Print(e)
		} else {
			shops = append(shops, s)
		}
	}
	return shops
}

func (a *shopRepo) UpdateShop(shop *model.Shop) error {
	tx, err := a.adapter.db.Begin()

	if err != nil {
		log.Printf("error beginning transaction: %s", err.Error())
		return err
	}
	if result, e := tx.Exec(a.adapter.getScript("update/shop"), shop.Name, shop.Street, shop.HouseNumber, shop.City, shop.PostalCode, shop.Infos, shop.ID); e != nil {
		return e
	} else {
		count, e := result.RowsAffected()
		if e != nil {
			log.Printf("error getting result: %s", e.Error())
			return e
		}
		if count != 1 {
			if er := tx.Rollback(); er != nil {
				log.Printf("error roling back: %s", er.Error())
				return er
			}
			return errors.New("error more than one row affected rolling back")
		}
		if er := tx.Commit(); er != nil {
			log.Printf("error commiting transcation: %s", er.Error())
		}
	}
	return nil
}

func (a *shopRepo) DeleteShopByID(id int64) error {
	tx, err := a.adapter.db.Begin()

	if err != nil {
		log.Printf("error beginning transaction: %s", err.Error())
		return nil
	}
	var result sql.Result
	result, err = tx.Exec(a.adapter.getScript("delete/shop"), id)
	if err != nil {
		log.Printf("error executing query: %s", err.Error())
		return err
	}
	var count int64
	count, err = result.RowsAffected()
	if err != nil {
		log.Printf("error getting result: %s", err.Error())
		return err
	}
	if count != 1 {
		log.Printf("error more then 1 row affected")
		if err = tx.Rollback(); err != nil {
			log.Printf("error rolling back: %s", err.Error())
		}
		return errors.New("error more then 1 row affected")
	} else {
		if err = tx.Commit(); err != nil {
			log.Printf("error comitting changes: %s", err.Error())
			return err
		}
	}
	return nil
}
